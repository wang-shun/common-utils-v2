/********************************************************************
 * This file is generated by program cap
 * Please do not change it directly
 * 
 * protocol name:LogServer
 * protocol version:200
 * protocol author:Jungleguo casper@tencent.com 4704652
 * protocol desc:
********************************************************************/

package com.youzan.sz.jutil.j4log;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.io.UnsupportedEncodingException;

public class LogPack {
	public static final long max_unsigned_32 = 1L + Integer.MAX_VALUE  + Integer.MAX_VALUE;
	public static class LogPack_Invalid extends RuntimeException {
		public LogPack_Invalid()
		{
		}
		public LogPack_Invalid(String s)
		{
			super(s);
		}
	}
	public static class String_pair {
		public String s;
		public int len;
	}
	public static interface command {
		int WriteSigle = 1;/* 写单条日志 */
		int WriteMulti = 2;/* 写多条日志 */
		int DeflatWriteSigle = 3;/* Deflat压缩的写单条日志 */
		int DeflatWriteMulti = 4;/* Deflat压缩的写多条日志 */
		int WriteSigleWithQQ = 5;/* 写单条日志,带QQ */
		int WriteMultiWithQQ = 6;/* 写多条日志,带QQ */
	}

	public static class MultiContent {
		public int Encode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(2 > leftsize) 
				throw new LogPack_Invalid("LogPack:MultiContent Encode fail: buffersize is too short");
			LogPack.h2n_16(buffer,(short)content.size(),offset+buffersize);
			buffersize+=2;
			leftsize-=2;
			for(int i=0;i<content.size();i++){
				spair.len = LogPack.encode_str4(buffer,(String)content.get(i),leftsize,offset+buffersize);
				buffersize+=spair.len;
				leftsize-=spair.len;
			}


			return buffersize;
		}

		public int Decode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(2 > leftsize) 
				throw new LogPack_Invalid("LogPack:MultiContent Decode fail: buffersize is too short");
			arraysize = LogPack.n2h_16(buffer,offset+buffersize);
			buffersize+=2; leftsize-=2; 
			content.clear();
			for(int i=0;i<arraysize;i++){
				spair = LogPack.decode_str4(buffer,leftsize,offset+buffersize);
				content.add(spair.s);
				buffersize += spair.len;
				leftsize -= spair.len;
			}


			return buffersize;
		}

		public ArrayList content = new ArrayList(); /* content */

		private String_pair spair = new String_pair();
		private int arraysize;
	};
	public static class MultiContentWithQQ {
		public int Encode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:MultiContentWithQQ Encode fail: buffer is too short");
			LogPack.h2n_unsigned_32(buffer,qq,offset+buffersize);
			buffersize+=4;
			leftsize-=4;

			spair.len = LogPack.encode_str2(buffer,content,leftsize,offset+buffersize);
			buffersize+=spair.len;
			leftsize-=spair.len;


			return buffersize;
		}

		public int Decode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:MultiContentWithQQ Decode fail: buffer is too short");
			qq=LogPack.n2h_unsigned_32(buffer,offset+buffersize);
			buffersize += 4;
			leftsize -= 4;

			spair = LogPack.decode_str2(buffer,leftsize,offset+buffersize);
			content = spair.s;
			buffersize += spair.len;
			leftsize -= spair.len;


			return buffersize;
		}

		public long qq; /* qq */
		public String content; /* content */

		private String_pair spair = new String_pair();
		private int arraysize;
	};

	public static class WriteSigleCS {
		public int Encode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			spair.len = LogPack.encode_str2(buffer,name,leftsize,offset+buffersize);
			buffersize+=spair.len;
			leftsize-=spair.len;

			spair.len = LogPack.encode_str2(buffer,content,leftsize,offset+buffersize);
			buffersize+=spair.len;
			leftsize-=spair.len;


			return buffersize;
		}

		public int Decode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			spair = LogPack.decode_str2(buffer,leftsize,offset+buffersize);
			name = spair.s;
			buffersize += spair.len;
			leftsize -= spair.len;

			spair = LogPack.decode_str2(buffer,leftsize,offset+buffersize);
			content = spair.s;
			buffersize += spair.len;
			leftsize -= spair.len;


			return buffersize;
		}

		public String name; /* log name */
		public String content; /* content */

		private String_pair spair = new String_pair();
		private int arraysize;
	};
	public static class WriteSigleSC {
		public int Encode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:WriteSigleSC Encode fail: buffer is too short");
			LogPack.h2n_unsigned_32(buffer,count,offset+buffersize);
			buffersize+=4;
			leftsize-=4;


			return buffersize;
		}

		public int Decode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:WriteSigleSC Decode fail: buffer is too short");
			count=LogPack.n2h_unsigned_32(buffer,offset+buffersize);
			buffersize += 4;
			leftsize -= 4;


			return buffersize;
		}

		public long count; /* count */

		private String_pair spair = new String_pair();
		private int arraysize;
	};
	public static class WriteMultiCS {
		public int Encode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			spair.len = LogPack.encode_str2(buffer,name,leftsize,offset+buffersize);
			buffersize+=spair.len;
			leftsize-=spair.len;

			if(2 > leftsize) 
				throw new LogPack_Invalid("LogPack:WriteMultiCS Encode fail: buffersize is too short");
			LogPack.h2n_16(buffer,(short)content.size(),offset+buffersize);
			buffersize+=2;
			leftsize-=2;
			for(int i=0;i<content.size();i++){
				spair.len = LogPack.encode_str4(buffer,(String)content.get(i),leftsize,offset+buffersize);
				buffersize+=spair.len;
				leftsize-=spair.len;
			}


			return buffersize;
		}

		public int Decode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			spair = LogPack.decode_str2(buffer,leftsize,offset+buffersize);
			name = spair.s;
			buffersize += spair.len;
			leftsize -= spair.len;

			if(2 > leftsize) 
				throw new LogPack_Invalid("LogPack:WriteMultiCS Decode fail: buffersize is too short");
			arraysize = LogPack.n2h_16(buffer,offset+buffersize);
			buffersize+=2; leftsize-=2; 
			content.clear();
			for(int i=0;i<arraysize;i++){
				spair = LogPack.decode_str4(buffer,leftsize,offset+buffersize);
				content.add(spair.s);
				buffersize += spair.len;
				leftsize -= spair.len;
			}


			return buffersize;
		}

		public String name; /* log name */
		public ArrayList content = new ArrayList(); /* content */

		private String_pair spair = new String_pair();
		private int arraysize;
	};
	public static class WriteMultiSC {
		public int Encode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:WriteMultiSC Encode fail: buffer is too short");
			LogPack.h2n_unsigned_32(buffer,count,offset+buffersize);
			buffersize+=4;
			leftsize-=4;


			return buffersize;
		}

		public int Decode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:WriteMultiSC Decode fail: buffer is too short");
			count=LogPack.n2h_unsigned_32(buffer,offset+buffersize);
			buffersize += 4;
			leftsize -= 4;


			return buffersize;
		}

		public long count; /* count */

		private String_pair spair = new String_pair();
		private int arraysize;
	};
	public static class DeflatWriteSigleCS {
		public int Encode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			spair.len = LogPack.encode_str2(buffer,name,leftsize,offset+buffersize);
			buffersize+=spair.len;
			leftsize-=spair.len;

			if(2 > leftsize) 
				throw new LogPack_Invalid("LogPack:DeflatWriteSigleCS Encode fail: buffersize is too short");
			LogPack.h2n_16(buffer,(short)content.length,offset+buffersize);
			buffersize+=2;
			leftsize-=2;
			if(content.length > leftsize) 
				throw new LogPack_Invalid("LogPack:DeflatWriteSigleCS Encode fail: buffersize is too short");
			if( content != null ){
				System.arraycopy(content,0,buffer,buffersize+offset,content.length);
				buffersize += content.length;
				leftsize -= content.length;
			}


			return buffersize;
		}

		public int Decode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			spair = LogPack.decode_str2(buffer,leftsize,offset+buffersize);
			name = spair.s;
			buffersize += spair.len;
			leftsize -= spair.len;

			if(2 > leftsize) 
				throw new LogPack_Invalid("LogPack:DeflatWriteSigleCS Decode fail: buffersize is too short");
			arraysize = LogPack.n2h_16(buffer,offset+buffersize);
			buffersize+=2; leftsize-=2; 
			if(arraysize > leftsize) 
				throw new LogPack_Invalid("LogPack:DeflatWriteSigleCS Decode fail: buffer is too short");
			content = new byte[arraysize];
			System.arraycopy(buffer,offset + buffersize,content,0,arraysize);
				buffersize += arraysize;
				leftsize -= arraysize;


			return buffersize;
		}

		public String name; /* log name */
		public byte[] content; /* content */

		private String_pair spair = new String_pair();
		private int arraysize;
	};
	public static class DeflatWriteSigleSC {
		public int Encode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:DeflatWriteSigleSC Encode fail: buffer is too short");
			LogPack.h2n_unsigned_32(buffer,count,offset+buffersize);
			buffersize+=4;
			leftsize-=4;


			return buffersize;
		}

		public int Decode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:DeflatWriteSigleSC Decode fail: buffer is too short");
			count=LogPack.n2h_unsigned_32(buffer,offset+buffersize);
			buffersize += 4;
			leftsize -= 4;


			return buffersize;
		}

		public long count; /* count */

		private String_pair spair = new String_pair();
		private int arraysize;
	};
	public static class DeflatWriteMultiCS {
		public int Encode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			spair.len = LogPack.encode_str2(buffer,name,leftsize,offset+buffersize);
			buffersize+=spair.len;
			leftsize-=spair.len;

			if(2 > leftsize) 
				throw new LogPack_Invalid("LogPack:DeflatWriteMultiCS Encode fail: buffersize is too short");
			LogPack.h2n_16(buffer,(short)content.length,offset+buffersize);
			buffersize+=2;
			leftsize-=2;
			if(content.length > leftsize) 
				throw new LogPack_Invalid("LogPack:DeflatWriteMultiCS Encode fail: buffersize is too short");
			if( content != null ){
				System.arraycopy(content,0,buffer,buffersize+offset,content.length);
				buffersize += content.length;
				leftsize -= content.length;
			}


			return buffersize;
		}

		public int Decode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			spair = LogPack.decode_str2(buffer,leftsize,offset+buffersize);
			name = spair.s;
			buffersize += spair.len;
			leftsize -= spair.len;

			if(2 > leftsize) 
				throw new LogPack_Invalid("LogPack:DeflatWriteMultiCS Decode fail: buffersize is too short");
			arraysize = LogPack.n2h_16(buffer,offset+buffersize);
			buffersize+=2; leftsize-=2; 
			if(arraysize > leftsize) 
				throw new LogPack_Invalid("LogPack:DeflatWriteMultiCS Decode fail: buffer is too short");
			content = new byte[arraysize];
			System.arraycopy(buffer,offset + buffersize,content,0,arraysize);
				buffersize += arraysize;
				leftsize -= arraysize;


			return buffersize;
		}

		public String name; /* log name */
		public byte[] content; /* content */

		private String_pair spair = new String_pair();
		private int arraysize;
	};
	public static class DeflatWriteMultiSC {
		public int Encode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:DeflatWriteMultiSC Encode fail: buffer is too short");
			LogPack.h2n_unsigned_32(buffer,count,offset+buffersize);
			buffersize+=4;
			leftsize-=4;


			return buffersize;
		}

		public int Decode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:DeflatWriteMultiSC Decode fail: buffer is too short");
			count=LogPack.n2h_unsigned_32(buffer,offset+buffersize);
			buffersize += 4;
			leftsize -= 4;


			return buffersize;
		}

		public long count; /* count */

		private String_pair spair = new String_pair();
		private int arraysize;
	};
	public static class WriteSigleWithQQCS {
		public int Encode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			spair.len = LogPack.encode_str2(buffer,name,leftsize,offset+buffersize);
			buffersize+=spair.len;
			leftsize-=spair.len;

			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:WriteSigleWithQQCS Encode fail: buffer is too short");
			LogPack.h2n_unsigned_32(buffer,qq,offset+buffersize);
			buffersize+=4;
			leftsize-=4;

			spair.len = LogPack.encode_str2(buffer,content,leftsize,offset+buffersize);
			buffersize+=spair.len;
			leftsize-=spair.len;


			return buffersize;
		}

		public int Decode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			spair = LogPack.decode_str2(buffer,leftsize,offset+buffersize);
			name = spair.s;
			buffersize += spair.len;
			leftsize -= spair.len;

			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:WriteSigleWithQQCS Decode fail: buffer is too short");
			qq=LogPack.n2h_unsigned_32(buffer,offset+buffersize);
			buffersize += 4;
			leftsize -= 4;

			spair = LogPack.decode_str2(buffer,leftsize,offset+buffersize);
			content = spair.s;
			buffersize += spair.len;
			leftsize -= spair.len;


			return buffersize;
		}

		public String name; /* log name */
		public long qq; /* qq */
		public String content; /* content */

		private String_pair spair = new String_pair();
		private int arraysize;
	};
	public static class WriteSigleWithQQSC {
		public int Encode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:WriteSigleWithQQSC Encode fail: buffer is too short");
			LogPack.h2n_unsigned_32(buffer,count,offset+buffersize);
			buffersize+=4;
			leftsize-=4;


			return buffersize;
		}

		public int Decode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:WriteSigleWithQQSC Decode fail: buffer is too short");
			count=LogPack.n2h_unsigned_32(buffer,offset+buffersize);
			buffersize += 4;
			leftsize -= 4;


			return buffersize;
		}

		public long count; /* count */

		private String_pair spair = new String_pair();
		private int arraysize;
	};
	public static class WriteMultiWithQQCS {
		public int Encode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			spair.len = LogPack.encode_str2(buffer,name,leftsize,offset+buffersize);
			buffersize+=spair.len;
			leftsize-=spair.len;

			if(2 > leftsize) 
				throw new LogPack_Invalid("LogPack:WriteMultiWithQQCS Encode fail: buffersize is too short");
			LogPack.h2n_16(buffer,(short)content.size(),offset+buffersize);
			buffersize+=2;
			leftsize-=2;
			for(int i=0;i<content.size();i++){
				spair.len = ((MultiContentWithQQ)content.get(i)).Encode(buffer,leftsize,offset+buffersize);
			buffersize+=spair.len;
			leftsize-=spair.len;
			}

			return buffersize;
		}

		public int Decode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			spair = LogPack.decode_str2(buffer,leftsize,offset+buffersize);
			name = spair.s;
			buffersize += spair.len;
			leftsize -= spair.len;

			if(2 > leftsize) 
				throw new LogPack_Invalid("LogPack:WriteMultiWithQQCS Decode fail: buffersize is too short");
			arraysize = LogPack.n2h_16(buffer,offset+buffersize);
			buffersize+=2; leftsize-=2; 
			content.clear();
			for(int i=0;i<arraysize;i++){
				MultiContentWithQQ stTmp = new MultiContentWithQQ();
				spair.len = stTmp.Decode(buffer,leftsize,offset+buffersize);
				content.add(stTmp);
				buffersize += spair.len;
				leftsize -= spair.len;
			}

			return buffersize;
		}

		public String name; /* log name */
		public ArrayList content = new ArrayList(); /* 具体见MultiContentWithQQ */

		private String_pair spair = new String_pair();
		private int arraysize;
	};
	public static class WriteMultiWithQQSC {
		public int Encode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:WriteMultiWithQQSC Encode fail: buffer is too short");
			LogPack.h2n_unsigned_32(buffer,count,offset+buffersize);
			buffersize+=4;
			leftsize-=4;


			return buffersize;
		}

		public int Decode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:WriteMultiWithQQSC Decode fail: buffer is too short");
			count=LogPack.n2h_unsigned_32(buffer,offset+buffersize);
			buffersize += 4;
			leftsize -= 4;


			return buffersize;
		}

		public long count; /* count */

		private String_pair spair = new String_pair();
		private int arraysize;
	};

	public static class packc {
		public int Encode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:packc Encode fail: buffer is too short");
			LogPack.h2n_unsigned_32(buffer,Len,offset+buffersize);
			buffersize+=4;
			leftsize-=4;

			if(2 > leftsize) 
				throw new LogPack_Invalid("LogPack:packc Encode fail: buffer is too short");
			LogPack.h2n_16(buffer,Ver,offset+buffersize);
			buffersize+=2;
			leftsize-=2;

			if(2 > leftsize) 
				throw new LogPack_Invalid("LogPack:packc Encode fail: buffer is too short");
			LogPack.h2n_16(buffer,Cmd,offset+buffersize);
			buffersize+=2;
			leftsize-=2;

			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:packc Encode fail: buffer is too short");
			LogPack.h2n_32(buffer,Time,offset+buffersize);
			buffersize+=4;
			leftsize-=4;

			switch(Cmd){
			case (short)command.WriteSigle:
				spair.len = csWriteSigle.Encode(buffer,leftsize,offset+buffersize);
				buffersize += spair.len;
				leftsize -= spair.len;
				break;
			case (short)command.WriteMulti:
				spair.len = csWriteMulti.Encode(buffer,leftsize,offset+buffersize);
				buffersize += spair.len;
				leftsize -= spair.len;
				break;
			case (short)command.DeflatWriteSigle:
				spair.len = csDeflatWriteSigle.Encode(buffer,leftsize,offset+buffersize);
				buffersize += spair.len;
				leftsize -= spair.len;
				break;
			case (short)command.DeflatWriteMulti:
				spair.len = csDeflatWriteMulti.Encode(buffer,leftsize,offset+buffersize);
				buffersize += spair.len;
				leftsize -= spair.len;
				break;
			case (short)command.WriteSigleWithQQ:
				spair.len = csWriteSigleWithQQ.Encode(buffer,leftsize,offset+buffersize);
				buffersize += spair.len;
				leftsize -= spair.len;
				break;
			case (short)command.WriteMultiWithQQ:
				spair.len = csWriteMultiWithQQ.Encode(buffer,leftsize,offset+buffersize);
				buffersize += spair.len;
				leftsize -= spair.len;
				break;
			default:
				break;
			}
			LogPack.h2n_unsigned_32(buffer,buffersize,0);

			return buffersize;
		}

		public int Decode(byte[] buffer,int leftsize,int offset)
		{
			int buffersize = 0;
			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:packc Decode fail: buffer is too short");
			Len=LogPack.n2h_unsigned_32(buffer,offset+buffersize);
			buffersize += 4;
			leftsize -= 4;

			if(2 > leftsize) 
				throw new LogPack_Invalid("LogPack:packc Decode fail: buffer is too short");
			Ver=LogPack.n2h_16(buffer,offset+buffersize);
			buffersize += 2;
			leftsize -= 2;

			if(2 > leftsize) 
				throw new LogPack_Invalid("LogPack:packc Decode fail: buffer is too short");
			Cmd=LogPack.n2h_16(buffer,offset+buffersize);
			buffersize += 2;
			leftsize -= 2;

			if(4 > leftsize) 
				throw new LogPack_Invalid("LogPack:packc Decode fail: buffer is too short");
			Time=LogPack.n2h_32(buffer,offset+buffersize);
			buffersize += 4;
			leftsize -= 4;

			switch(Cmd){
			case (short)command.WriteSigle:
				arraysize = csWriteSigle.Decode(buffer,leftsize,offset+buffersize);
				buffersize += arraysize;
				leftsize -= arraysize;
				break;
			case (short)command.WriteMulti:
				arraysize = csWriteMulti.Decode(buffer,leftsize,offset+buffersize);
				buffersize += arraysize;
				leftsize -= arraysize;
				break;
			case (short)command.DeflatWriteSigle:
				arraysize = csDeflatWriteSigle.Decode(buffer,leftsize,offset+buffersize);
				buffersize += arraysize;
				leftsize -= arraysize;
				break;
			case (short)command.DeflatWriteMulti:
				arraysize = csDeflatWriteMulti.Decode(buffer,leftsize,offset+buffersize);
				buffersize += arraysize;
				leftsize -= arraysize;
				break;
			case (short)command.WriteSigleWithQQ:
				arraysize = csWriteSigleWithQQ.Decode(buffer,leftsize,offset+buffersize);
				buffersize += arraysize;
				leftsize -= arraysize;
				break;
			case (short)command.WriteMultiWithQQ:
				arraysize = csWriteMultiWithQQ.Decode(buffer,leftsize,offset+buffersize);
				buffersize += arraysize;
				leftsize -= arraysize;
				break;
			default:
				break;
			}

			return buffersize;
		}

		public long Len; /* 长度，标识整个包长 */
		public short Ver; /*  */
		public short Cmd; /*  */
		public int Time; /*  */
		public WriteSigleCS csWriteSigle = new WriteSigleCS();
		public WriteMultiCS csWriteMulti = new WriteMultiCS();
		public DeflatWriteSigleCS csDeflatWriteSigle = new DeflatWriteSigleCS();
		public DeflatWriteMultiCS csDeflatWriteMulti = new DeflatWriteMultiCS();
		public WriteSigleWithQQCS csWriteSigleWithQQ = new WriteSigleWithQQCS();
		public WriteMultiWithQQCS csWriteMultiWithQQ = new WriteMultiWithQQCS();

		private String_pair spair = new String_pair();
		private int arraysize;
	};

	public packc client = new packc();
//	public packs server = new packs();


	public static byte[] getBytes(String s)
	{
		try {
			return s.getBytes("gbk");
		} catch(UnsupportedEncodingException e) {
			return s.getBytes();
		}
	}

	public static String newS(byte[] bytes,int offset,int length)
	{
		try {
			return new String(bytes,offset,length,"gbk");
		} catch(UnsupportedEncodingException e) {
			return new String(bytes,offset,length);
		}
	}

	public static int encode_str(byte[] buffer,String src,int leftsize,int offset)
	{
		int buffersize = 0;
		byte[] b = getBytes(src);
		if(b.length+1 > leftsize)
			throw new LogPack_Invalid("LogPack:encode_str fail: buffersize is too short");
		System.arraycopy(b, 0, buffer, offset, b.length);
//		memcpy(buffer,b,offset);
		buffersize+=(int)b.length;
		leftsize-=(int)b.length;
//		just like a bug,
//		buffer[offset+buffersize] = (byte)b.length;
		buffersize++;
		leftsize--;
		return buffersize;
	}
	public static int encode_str1(byte[] buffer,String src,int leftsize,int offset)
	{
		int buffersize = 0;
		byte[] b = getBytes(src);
		if(b.length+1 > leftsize){
			throw new LogPack_Invalid("LogPack:encode_str1 fail: buffersize is too short");
		}
		if(b.length > 255){
			throw new LogPack_Invalid("LogPack:encode_str1 fail: the max length of string1 is 255");
		}
		buffer[offset+buffersize] = (byte)b.length;
		buffersize++;
		leftsize--;
		System.arraycopy(b, 0, buffer, offset + buffersize, b.length);
//		memcpy(buffer,b,offset+buffersize);
		buffersize+=(int)b.length;
		leftsize-=(int)b.length;
		return buffersize;
	}
	public static int encode_str2(byte[] buffer,String src,int leftsize,int offset)
	{
		int buffersize = 0;
		byte[] b = getBytes(src);
		if(b.length+2 > leftsize){
			throw new LogPack_Invalid("LogPack:encode_str2 fail: buffersize is too short");
		}
		if(b.length > 65535){
			throw new LogPack_Invalid("LogPack:encode_str2 fail: the max length of string1 is 65535");
		}
		LogPack.h2n_16(buffer,(short)b.length,offset+buffersize);
		buffersize+=2;
		leftsize-=2;
		System.arraycopy(b, 0, buffer, offset + buffersize, b.length);
//		memcpy(buffer,b,offset+buffersize);
		buffersize+=(int)b.length;
		leftsize-=(int)b.length;
		return buffersize;
	}
	public static int encode_str4(byte[] buffer,String src,int leftsize,int offset)
	{
		int buffersize = 0;
		byte[] b = getBytes(src);
		if(b.length+4 > leftsize)
			throw new LogPack_Invalid("LogPack:encode_str4 fail: buffersize is too short");
		LogPack.h2n_32(buffer,(int)b.length,offset+buffersize);
		buffersize+=4;
		leftsize-=4;
		System.arraycopy(b, 0, buffer, offset + buffersize, b.length);
//		memcpy(buffer,b,offset+buffersize);
		buffersize+=(int)b.length;
		leftsize-=(int)b.length;
		return buffersize;
	}

	public static String_pair decode_str(byte[] buffer, int leftsize, int offset)
	{
		int buffersize=0;
		String_pair s = new String_pair();
		s.len = 0;
		for(int i=0;i<leftsize;i++) {
			if(buffer[offset+i] == '\0') {
				s.len = i;
				break;
			}
		}
		if(s.len+1 > leftsize)
			throw new LogPack_Invalid("LogPack:decode_str fail: buffersize is too short");
		s.s = newS(buffer,(int)(offset+buffersize),(int)s.len);
		s.len++;
		return s;
	}
	public static String_pair decode_str1(byte[] buffer, int leftsize, int offset)
	{
		int buffersize=0;
		String_pair s = new String_pair();
		s.len = toUnsignedByte(buffer[offset]);
		buffersize++;
		leftsize--;
		if(s.len > leftsize) 
			throw new LogPack_Invalid("LogPack:decode_str1 fail: buffersize is too short");
		s.s = newS(buffer,(int)(offset+buffersize),(int)s.len);
		s.len++;
		return s;
	}
	public static String_pair decode_str2(byte[] buffer, int leftsize, int offset)
	{
		int buffersize=0;
		String_pair s = new String_pair();
		s.len = toUnsignedShort(LogPack.n2h_16(buffer,offset));
		buffersize+=2;
		leftsize-=2;
		if(s.len > leftsize) 
			throw new LogPack_Invalid("LogPack:decode_str2 fail: buffersize is too short");
		s.s = newS(buffer,(int)(offset+buffersize),(int)s.len);
		s.len+=2;
		return s;
	}
	public static String_pair decode_str4(byte[] buffer, int leftsize, int offset)
	{
		int buffersize=0;
		String_pair s = new String_pair();
		s.len = LogPack.n2h_32(buffer,offset);
		buffersize+=4;
		leftsize-=4;
		if(s.len > leftsize)
			throw new LogPack_Invalid("LogPack:decode_str4 fail: buffersize is too short");
		s.s = newS(buffer,(int)(offset+buffersize),(int)s.len);
		s.len+=4;
		return s;
	}

	public static void h2n_32(byte[] dest,int i, int offset)
	{
//		slow code
//		ByteBuffer bb = ByteBuffer.allocate(4);
//		bb.putInt(i);
//		byte[] b = bb.array();
//		dest[offset] = b[0];
//		dest[offset+1] = b[1];
//		dest[offset+2] = b[2];
//		dest[offset+3] = b[3];
		ByteBuffer bb = ByteBuffer.wrap(dest, offset, 4);
		bb.putInt(i);
	}

	public static void h2n_16(byte[] dest,short i, int offset)
	{
//		slow code
//		ByteBuffer bb = ByteBuffer.allocate(2);
//		bb.putShort(i);
//		byte[] b = bb.array();
//		dest[offset] = b[0];
//		dest[offset+1] = b[1];
		ByteBuffer bb = ByteBuffer.wrap(dest, offset, 2);
		bb.putShort(i);
	}

	public static int n2h_32(byte[] src, int offset)
	{
		ByteBuffer bb = ByteBuffer.wrap(src, offset, 4);
		return bb.getInt();
	}
	public static short n2h_16(byte[] src, int offset)
	{
		ByteBuffer bb = ByteBuffer.wrap(src, offset, 2);
		return bb.getShort();
	}

	//from java.nio.Bits
    private static byte long3(long x) { return (byte)(x >> 24); }
    private static byte long2(long x) { return (byte)(x >> 16); }
    private static byte long1(long x) { return (byte)(x >>  8); }
    private static byte long0(long x) { return (byte)(x >>  0); }

	public static void h2n_unsigned_32(byte[] dest,long i, int offset)
	{
		if(i > max_unsigned_32){
			throw new RuntimeException("unsigned int big than " + max_unsigned_32 + ", can not support :" + i);
		}else if( i < 0){
			throw new RuntimeException("can not encode negative number:" + i + " in unsigned int!");
		}
		dest[offset] = long3(i);
		dest[offset+1] = long2(i);
		dest[offset+2] = long1(i);
		dest[offset+3] = long0(i);
	}

	//from java.nio.Bits
    static private long makeLong(byte b7, byte b6, byte b5, byte b4,
			 byte b3, byte b2, byte b1, byte b0){
	return ((((long)b7 & 0xff) << 56) |
		(((long)b6 & 0xff) << 48) |
		(((long)b5 & 0xff) << 40) |
		(((long)b4 & 0xff) << 32) |
		(((long)b3 & 0xff) << 24) |
		(((long)b2 & 0xff) << 16) |
		(((long)b1 & 0xff) <<  8) |
		(((long)b0 & 0xff) <<  0));
	}

	public static long n2h_unsigned_32(byte[] src, int offset)
	{
		return makeLong((byte) 0, (byte) 0, (byte) 0, (byte) 0, src[offset], src[offset + 1], src[offset + 2], src[offset + 3]);
	}

	public static short toUnsignedByte(byte b){
		short rValue = 0 ;
		if(b >= 0){
			rValue = b;
		}
		else{
			rValue = (short)(256 + b);
		}
		return rValue;
	}

	public static int toUnsignedShort(short s){
		int rValue = 0 ;
		if(s >= 0){
			rValue = s;
		}
		else{
			rValue = (int)(65536 + s);
		}
		return rValue;
	}
}

